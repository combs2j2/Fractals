# MandelbrotPython

The Mandelbrot set produces what is considered one of the most aesthetically pleasing visualizations in all of mathematics. The rule for inclusion in the Mandelbrot set are relatively simple. Let c be a complex number. That is, c = a + bi where a and b are real numbers and i is the imaginary unit (sqrt(-1)). Consider the recurrence relation z(n+1) = z(n) + c where z(i) is also an imaginary number and the base case z(0) = 0. If |z(n)|, the distance z(n) is from the origin (0,0) remains bounded for all n, that is, there is some number that |z(n)| is always less than or equal to, then c is in the Mandelbrot set. Otherwise, c is not included in the set. Mathemematicians have proven that if |z(n)| > 2 for any n, then |z(n)| is unbounded, and vice versa. Effectively, this means that inclusion within the Mandelbrot set boils down to whether or not |z(n)| ever exceeds 2.

Visualizations of the Mandelbrot set are built upon how quickly applying our recurrence relation to c results in divergence. In other words, what the first value of n is for which |z(n)| exceeds 2. We assign a color to each n, and for every c, we plot this color on the complex plane, where the x-axis represents the real part (a) of a complex number and the y-axis represents the imaginary paer (b) of the complex number. The resulting plot produces a very enticing fractal that upon zooming in on the apparent "boundary" reveals infinitely complex and recursive patterns.

With limited memory and an infinite number of calculations and points needed to produce the entire set and its visualization, one can only ever hope to produce a good approximation. This is done in a few ways. First, we decide on a number for which when n reaches that number and |z(n)| has not yet exceeded 2, we "throw our hands" and declare the chosen c to be a member of the set. The higher that number is, the closer we get to producing the set. To produce the visualization, we decide on maximums and minimums for the real and imaginary parts for the c's we wish to plot for, and partition those ranges into sets of a specified number of evenly spaced values. This results in samples of complex numbers for which we determine if and how quickly |z(n)| exceeds 2. We assign each c a portion of the graph, and plot its resulting color. The larger the sets, the higher the resolution of the plot will be, and the higher the maximum number of iterations, the more continuous the coloring of the image is and the more accurate the resulting fractal is.

Producing a relativly accurate visualization is quite time consuming (Time complexity O(n^2) on the resolution of the image). To combat this, this particular implementation utilizes parallel computing over all the logical processors on the machine running the program. This seems to make the program run about 2.5 times faster (with 8 logical processors). 
